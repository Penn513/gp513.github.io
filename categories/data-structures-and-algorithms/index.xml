<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Data Structures and Algorithms - Category - WAIT | HOPE</title>
        <link>https://penn513.github.io/categories/data-structures-and-algorithms/</link>
        <description>Data Structures and Algorithms - Category - WAIT | HOPE</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 15 Jul 2021 15:58:26 &#43;0800</lastBuildDate><atom:link href="https://penn513.github.io/categories/data-structures-and-algorithms/" rel="self" type="application/rss+xml" /><item>
    <title>数据结构与算法 - 并查集</title>
    <link>https://penn513.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/</link>
    <pubDate>Thu, 15 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%B9%B6%E6%9F%A5%E9%9B%86/</guid>
    <description><![CDATA[概念 并查集： Disjoint-Set，是用于处理一些不交集的合并及查询问题的一种数据结构，支持查询、合并以及添加操作。 合并： Union，简单]]></description>
</item><item>
    <title>数据结构与算法 - BFS</title>
    <link>https://penn513.github.io/bfs/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/bfs/</guid>
    <description><![CDATA[框架1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def BFS(start, target): queue = collections.deque() visited = set() queue.append(start) visited.add(start) step = 0 while queue: size = len(queue) for i in range(size): cur = queue.popleft() if cur == target: return step for node in cur: if not node in visited(): queue.append(node) visited.add(node) step += 1 return step 例]]></description>
</item><item>
    <title>数据结构与算法 - LRU &amp; LFU</title>
    <link>https://penn513.github.io/lrulfu/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/lrulfu/</guid>
    <description><![CDATA[LRU1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class LRUCache: def __init__(self, capacity): self.capacity = capacity self.queue = collections.OrderedDict() def get(self, key): if key not in self.queue: return -1 value = self.queue.pop(key) self.queue[key] = value # 将命中的数据重新添加至头部 return self.queue[key] def put(self, key): if key]]></description>
</item><item>
    <title>数据结构与算法 - 二分查找</title>
    <link>https://penn513.github.io/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[模板 1 - 二分查找1 2 3 4 5 6 7 8 9 10 11 12 13 14 def binary_search(nums, target): if len(nums) &lt;= 0: return -1 left, right = 0, len(nums) - 1 # 查找区间[left, right] while left &lt;= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif]]></description>
</item><item>
    <title>数据结构与算法 - 优先队列</title>
    <link>https://penn513.github.io/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</guid>
    <description><![CDATA[简介优先队列算法，也成为堆队列算法。堆是一个二叉树，它的每个父节点都小于等于孩子节点。heapq实现了一个适合与Python的列表一起使用的]]></description>
</item><item>
    <title>数据结构与算法 - 前缀和</title>
    <link>https://penn513.github.io/%E5%89%8D%E7%BC%80%E5%92%8C/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%89%8D%E7%BC%80%E5%92%8C/</guid>
    <description><![CDATA[简介前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 例题 1 - 和为K的子数组https://leetcode-cn]]></description>
</item><item>
    <title>数据结构与算法 - 动态规划</title>
    <link>https://penn513.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
    <description><![CDATA[简介 状态定义 状态转移方程 初始状态 返回值 例题 1 - 打家劫舍IIhttps://leetcode-cn.com/problems/house-ro]]></description>
</item><item>
    <title>数据结构与算法 - 单调栈</title>
    <link>https://penn513.github.io/%E5%8D%95%E8%B0%83%E6%A0%88/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%8D%95%E8%B0%83%E6%A0%88/</guid>
    <description><![CDATA[性质 单调递减栈，能表示入栈元素左边第一个比它大的元素。入栈表明本身比栈顶小，出栈表面本身比栈顶大； 单调递增栈，能表示入栈元素左边第一个比它小]]></description>
</item><item>
    <title>数据结构与算法 - 回溯&amp;DFS</title>
    <link>https://penn513.github.io/%E5%9B%9E%E6%BA%AFdfs/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%9B%9E%E6%BA%AFdfs/</guid>
    <description><![CDATA[简介解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 路径：也就是已经做出的选择。 选择列表：也就是你当前可以做的选择。]]></description>
</item><item>
    <title>数据结构与算法 - 字典树</title>
    <link>https://penn513.github.io/%E5%AD%97%E5%85%B8%E6%A0%91/</link>
    <pubDate>Mon, 12 Jul 2021 15:58:26 &#43;0800</pubDate>
    <author>GP</author>
    <guid>https://penn513.github.io/%E5%AD%97%E5%85%B8%E6%A0%91/</guid>
    <description><![CDATA[简介https://leetcode-cn.com/problems/short-encoding-of-words/solution/99]]></description>
</item></channel>
</rss>
