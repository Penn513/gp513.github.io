[{"categories":["Paters"],"content":"MonoFlex阅读笔记。","date":"2022-01-12","objectID":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["Papers","Deep Learning","3D","Object Detection"],"title":"MonoFlex阅读笔记","uri":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"Abstract作者提出一个3D目标检测模型，将截断的目标解耦出来，并将多种深度估计方法结合使用。特别地，作者将特征图的边缘解耦，专门用于长尾分布的截断目标的检测，避免了对正常目标的影响。将目标深度估计公式化为，直接回归的目标深度，以及不同分组关键点求解的深度，进行不确定引导集成。实验证实，该方法比SOTA方法提升27%，KITTI benchmark保证实时的前提下提升30%。 ","date":"2022-01-12","objectID":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:1","tags":["Papers","Deep Learning","3D","Object Detection"],"title":"MonoFlex阅读笔记","uri":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"INTRODUCTIONSOTA方法对严重截断的目标检测效果仍然不好，然而这些目标对自动驾驶的安全性而言又是至关重要的。文章提出方法，对截断目标的检测效果有明显改善。 \rFigure1\r ","date":"2022-01-12","objectID":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:2","tags":["Papers","Deep Learning","3D","Object Detection"],"title":"MonoFlex阅读笔记","uri":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"References Objects are Different: Flexible Monocular 3D Object Detection https://github.com/zhangyp15/MonoFlex ","date":"2022-01-12","objectID":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:3","tags":["Papers","Deep Learning","3D","Object Detection"],"title":"MonoFlex阅读笔记","uri":"/monoflex%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"Swin-Transformer笔记。","date":"2022-01-12","objectID":"/swin-transformer%E7%AC%94%E8%AE%B0/","tags":["Papers","Deep Learning","Transformer","CV"],"title":"Swin-Transformer笔记","uri":"/swin-transformer%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"前期工作why 优美 统一建模 知识共享 VIT 示意图 问题 未考虑视觉信号特点，平移不变性，只适合分类，不适合更精细的问题 global attention，计算量跟分辨率指数关系 ","date":"2022-01-12","objectID":"/swin-transformer%E7%AC%94%E8%AE%B0/:0:1","tags":["Papers","Deep Learning","Transformer","CV"],"title":"Swin-Transformer笔记","uri":"/swin-transformer%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"Swin-Transformerhttps://github.com/microsoft/Swin-Transformer https://paperswithcode.com/ SOTA方法对严重截断的目标检测效果仍然不好，然而这些目标对自动驾驶的安全性而言又是至关重要的。文章提出方法，对截断目标的检测效果有明显改善。 \rFigure1\r ","date":"2022-01-12","objectID":"/swin-transformer%E7%AC%94%E8%AE%B0/:0:2","tags":["Papers","Deep Learning","Transformer","CV"],"title":"Swin-Transformer笔记","uri":"/swin-transformer%E7%AC%94%E8%AE%B0/"},{"categories":["Paters"],"content":"References Objects are Different: Flexible Monocular 3D Object Detection https://github.com/zhangyp15/MonoFlex ","date":"2022-01-12","objectID":"/swin-transformer%E7%AC%94%E8%AE%B0/:0:3","tags":["Papers","Deep Learning","Transformer","CV"],"title":"Swin-Transformer笔记","uri":"/swin-transformer%E7%AC%94%E8%AE%B0/"},{"categories":["Data Structures and Algorithms"],"content":"并查集(Disjoint-Set)是一种可以动态维护若干个不重叠的集合，并支持合并与查询两种操作的一种数据结构。","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"概念 并查集： Disjoint-Set，是用于处理一些不交集的合并及查询问题的一种数据结构，支持查询、合并以及添加操作。 合并： Union，简单来说，就是把有关联的节点视为一个集群，每个集群用一个祖宗节点来表示。 查询： Find，指的是依次查找某个节点的父节点，直至祖宗节点。 路径压缩： 随着节点的加入，族谱层级可能会很深，这样查找效率很低。因此可以在由下至上查询的过程中，让当前向上移动，进而降低族谱层级，这就是路径压缩，单词操作复杂度为O(logN)。 ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"代码模板 class DisjointSet(object): \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n def get_root(self, i): # 路径压缩：在查找的过程中向root节点移动，以减少层数 # 根节点的父节点是它自己 if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 朋友圈（省份数量）https://leetcode-cn.com/problems/number-of-provinces/ 省份数量\r class DisjointSet: \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n self.num_of_sets = n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_sets -= 1 def add(self, x): if x not in self.parent: self.parent[x] = None class Solution: def findCircleNum(self, isConnected: List[List[int]]) -\u003e int: uf = DisjointSet(len(isConnected)) for i in range(len(isConnected)): for j in range(i): if isConnected[i][j] and not uf.is_connected(i, j): uf.union(i, j) return uf.num_of_sets ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 岛屿数量https://leetcode-cn.com/problems/number-of-islands/ 岛屿数量\r class DisjointSet: \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) self.rank = [1] * n self.num_of_sets = n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 若两个节点在同一集合中，跳过 if i_root == j_root: return # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_sets -= 1 def add(self, x): if x not in self.parent: self.parent[x] = None class Solution: def numIslands(self, grid: List[List[str]]) -\u003e int: m, n = len(grid), len(grid[0]) uf = DisjointSet(m*n) # i*num_col + j 作为唯一标识 for i in range(m): for j in range(n): if grid[i][j] == \"0\": uf.num_of_sets -= 1 continue if j + 1 \u003c n and grid[i][j + 1] == \"1\": uf.union(i*n + j, i*n + j + 1) if i + 1 \u003c m and grid[i + 1][j] == \"1\": uf.union(i*n + j, (i + 1)*n + j) return uf.num_of_sets ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 3 - 尽量减少恶意软件的传播https://leetcode-cn.com/problems/minimize-malware-spread/ 恶意软件传播\r class DisjointSet(object): \"并查集\" def __init__(self, n): \"\"\" parent[i]表示节点i的父节点，初始化parent[i] = i，即每个节点的父节点均为自己 rank[i]表示当前节点的后代层数，包括自己 \"\"\" self.parent = list(range(n)) # 记录每棵树高度，用于优化合并查找效率 self.rank = [1] * n # 记录每棵树中的传播源数量，这题里传播源数量大于1时，减少一个源并无效 self.num_of_source = [0] * n # 记录每课树的节点树，判断可能传播的节点数量 self.num_of_node = [1] * n def get_root(self, i): if self.parent[i] != self.parent[self.parent[i]]: self.parent[i] = self.get_root(self.parent[i]) return self.parent[i] def is_connected(self, i, j): return self.get_root(i) == self.get_root(j) def union(self, i, j): i_root = self.get_root(i) j_root = self.get_root(j) # 合并的时候，将层数少的树连接到层数多的树，以减少合并树的高度 if self.rank[i_root] == self.rank[j_root]: self.parent[i_root] = j_root self.rank[j_root] += 1 elif self.rank[i_root] \u003e self.rank[j_root]: self.parent[j_root] = i_root else: self.parent[i_root] = j_root self.num_of_node[i_root] += 1 self.num_of_node[j_root] += 1 class Solution: def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -\u003e int: uf = DisjointSet(len(graph)) for i in range(len(graph)): for j in range(i): if graph[i][j]: uf.union(i, j) for _, v in enumerate(initial): uf.num_of_source[uf.get_root(v)] += 1 # 效果相同时返回索引小的节点，用例里并非顺序排列，因此先排序 initial.sort() res = initial[0] max_virus = 0 for k in initial: root = uf.get_root(k) if uf.num_of_source[root] == 1 and uf.num_of_node[root] \u003e max_virus: max_virus = uf.num_of_node[root] res = k return res ","date":"2021-07-15","objectID":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/:0:5","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 并查集","uri":"/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"categories":["Linux"],"content":"perf_events is an event-oriented observability tool, which can help you solve advanced performance and troubleshooting functions","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"perf也被称为perf_events，是一个面向event的观察工具，可用于性能剖析或内核故障排查。perf是内核的一部分，随内核发布。 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:0","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"事件（Events）事件分类： Hardware Events: CPU performance monitoring counters. Software Events: These are low level events based on kernel counters. For example, CPU migrations, minor faults, major faults, etc. Kernel Tracepoint Events: This are static kernel-level instrumentation points that are hardcoded in interesting and logical places in the kernel. User Statically-Defined Tracing (USDT): These are static tracepoints for user-level programs and applications. Dynamic Tracing: Software can be dynamically instrumented, creating events in any location. For kernel software, this uses the kprobes framework. For user-level software, uprobes. Timed Profiling: Snapshots can be collected at an arbitrary frequency, using perf record -FHz. This is commonly used for CPU usage profiling, and works by creating custom timed interrupt events. # perf list List of pre-defined events (to be used in -e): cpu-cycles OR cycles [Hardware event] instructions [Hardware event] cache-references [Hardware event] cache-misses [Hardware event] branch-instructions OR branches [Hardware event] branch-misses [Hardware event] bus-cycles [Hardware event] stalled-cycles-frontend OR idle-cycles-frontend [Hardware event] stalled-cycles-backend OR idle-cycles-backend [Hardware event] ref-cycles [Hardware event] cpu-clock [Software event] task-clock [Software event] page-faults OR faults [Software event] context-switches OR cs [Software event] cpu-migrations OR migrations [Software event] minor-faults [Software event] major-faults [Software event] alignment-faults [Software event] emulation-faults [Software event] L1-dcache-loads [Hardware cache event] L1-dcache-load-misses [Hardware cache event] L1-dcache-stores [Hardware cache event] [...] rNNN [Raw hardware event descriptor] cpu/t1=v1[,t2=v2,t3 ...]/modifier [Raw hardware event descriptor] (see 'man perf-list' on how to encode it) mem:\u003caddr\u003e[:access] [Hardware breakpoint] probe:tcp_sendmsg [Tracepoint event] [...] sched:sched_process_exec [Tracepoint event] sched:sched_process_fork [Tracepoint event] sched:sched_process_wait [Tracepoint event] sched:sched_wait_task [Tracepoint event] sched:sched_process_exit [Tracepoint event] [...] # perf list | wc -l 657 ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:1","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"示例最近遇到个问题，程序的所有线程都被绑到0核上，但运行时并未使用taskset绑核。linux的绑核是通过系统调用syscalls:sys_enter_sched_setaffinity，进而考虑使用perf跟踪该系统调用，查看调用栈。 # 开启事件跟踪 perf record -g -e \"syscalls:sys_enter_sched_setaffinity\" -a # 另开启一个session，运行程序 # 通过Ctrl+c结束perf，在当前路径生成perf.data # 查看调用栈 perf script ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:2","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"命令列出事件Listing Events # Listing all currently known events: perf list # Listing sched tracepoints: perf list 'sched:*' 计数事件Counting Events # CPU counter statistics for the specified command: perf stat command # Detailed CPU counter statistics (includes extras) for the specified command: perf stat -d command # CPU counter statistics for the specified PID, until Ctrl-C: perf stat -p PID # CPU counter statistics for the entire system, for 5 seconds: perf stat -a sleep 5 # Various basic CPU statistics, system wide, for 10 seconds: perf stat -e cycles,instructions,cache-references,cache-misses,bus-cycles -a sleep 10 # Various CPU level 1 data cache statistics for the specified command: perf stat -e L1-dcache-loads,L1-dcache-load-misses,L1-dcache-stores command # Various CPU data TLB statistics for the specified command: perf stat -e dTLB-loads,dTLB-load-misses,dTLB-prefetch-misses command # Various CPU last level cache statistics for the specified command: perf stat -e LLC-loads,LLC-load-misses,LLC-stores,LLC-prefetches command # Using raw PMC counters, eg, counting unhalted core cycles: perf stat -e r003c -a sleep 5 # PMCs: counting cycles and frontend stalls via raw specification: perf stat -e cycles -e cpu/event=0x0e,umask=0x01,inv,cmask=0x01/ -a sleep 5 # Count syscalls per-second system-wide: perf stat -e raw_syscalls:sys_enter -I 1000 -a # Count system calls by type for the specified PID, until Ctrl-C: perf stat -e 'syscalls:sys_enter_*' -p PID # Count system calls by type for the entire system, for 5 seconds: perf stat -e 'syscalls:sys_enter_*' -a sleep 5 # Count scheduler events for the specified PID, until Ctrl-C: perf stat -e 'sched:*' -p PID # Count scheduler events for the specified PID, for 10 seconds: perf stat -e 'sched:*' -p PID sleep 10 # Count ext4 events for the entire system, for 10 seconds: perf stat -e 'ext4:*' -a sleep 10 # Count block device I/O events for the entire system, for 10 seconds: perf stat -e 'block:*' -a sleep 10 # Count all vmscan events, printing a report every second: perf stat -e 'vmscan:*' -a -I 1000 性能剖析Profiling # Sample on-CPU functions for the specified command, at 99 Hertz: perf record -F 99 command # Sample on-CPU functions for the specified PID, at 99 Hertz, until Ctrl-C: perf record -F 99 -p PID # Sample on-CPU functions for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID sleep 10 # Sample CPU stack traces (via frame pointers) for the specified PID, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID -g -- sleep 10 # Sample CPU stack traces for the PID, using dwarf (dbg info) to unwind stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -p PID --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003c Linux 4.11): perf record -F 99 -ag -- sleep 10 # Sample CPU stack traces for the entire system, at 99 Hertz, for 10 seconds (\u003e= Linux 4.11): perf record -F 99 -g -- sleep 10 # If the previous command didn't work, try forcing perf to use the cpu-clock event: perf record -F 99 -e cpu-clock -ag -- sleep 10 # Sample CPU stack traces for a container identified by its /sys/fs/cgroup/perf_event cgroup: perf record -F 99 -e cpu-clock --cgroup=docker/1d567f4393190204...etc... -a -- sleep 10 # Sample CPU stack traces for the entire system, with dwarf stacks, at 99 Hertz, for 10 seconds: perf record -F 99 -a --call-graph dwarf sleep 10 # Sample CPU stack traces for the entire system, using last branch record for stacks, ... (\u003e= Linux 4.?): perf record -F 99 -a --call-graph lbr sleep 10 # Sample CPU stack traces, once every 10,000 Level 1 data cache misses, for 5 seconds: perf record -e L1-dcache-load-misses -c 10000 -ag -- sleep 5 # Sample CPU stack traces, once every 100 last level cache misses, for 5 seconds: perf record -e LLC-load-misses -c 100 -ag -- sleep 5 # Sample on-CPU kernel instructions, for 5 seconds: perf record -e cycles:k -a -- sleep 5 # Sample on-CPU user instructions, for 5 seconds: perf record -e cycle","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:3","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"参考https://www.brendangregg.com/perf.html ","date":"2021-07-14","objectID":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/:0:4","tags":["Linux"],"title":"Linux - perf性能分析","uri":"/perf%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["Git"],"content":"git使用。","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"1. 子仓同步主仓 新增主仓代码库 git remote add upstream 'xxx.git' 拉取主仓代码至本地master分支 git pull upstream master 提交本地代码至远程子仓 git push ","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/:0:1","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"2. 强制push，覆盖远程仓库 回退本地代码至前一次提交 git reset --soft HEAD~1 强制push，覆盖远程 git push -u origin master -f ","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/:0:2","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"3. 下载大仓库 clone最新代码 git clone xxx.git --depth=1 历史记录 git fetch --unshallow ","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/:0:3","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"4. 子模块 方式一：直接clone git clone --recursive xxx.git 方式二： 已经clone后下载子模块 git submodule update --init --recursive ","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/:0:4","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"5. 合并提交合并已经push到远程仓库的commit。 查看需要合并的最近提交记录 git log 合并最近三次的提交 git rebase -i HEAD~3 将需要被合并的commit前的pick修改为s。 强制提交到远程 git push -f ","date":"2021-07-12","objectID":"/git%E4%BD%BF%E7%94%A8/:0:5","tags":["Git"],"title":"Git使用","uri":"/git%E4%BD%BF%E7%94%A8/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - BFS。","date":"2021-07-12","objectID":"/bfs/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - BFS","uri":"/bfs/"},{"categories":["Data Structures and Algorithms"],"content":"框架 def BFS(start, target): queue = collections.deque() visited = set() queue.append(start) visited.add(start) step = 0 while queue: size = len(queue) for i in range(size): cur = queue.popleft() if cur == target: return step for node in cur: if not node in visited(): queue.append(node) visited.add(node) step += 1 return step ","date":"2021-07-12","objectID":"/bfs/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - BFS","uri":"/bfs/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 打开转盘锁https://leetcode-cn.com/problems/open-the-lock/ 打开转盘锁\r class Solution: def up(self, code, index): code_list = list(code) if code_list[index] == '9': code_list[index] = '0' else: code_list[index] = str(int(code_list[index]) + 1) return ''.join(code_list) def down(self, code, index): code_list = list(code) if code_list[index] == '0': code_list[index] = '9' else: code_list[index] = str(int(code_list[index]) - 1) return ''.join(code_list) def openLock(self, deadends: List[str], target: str) -\u003e int: queue = collections.deque() visited = set() # 将死亡数字视为已访问，避免进入分支 for i in range(len(deadends)): visited.add(deadends[i]) queue.append('0000') step = 0 while queue: size = len(queue) for i in range(size): cur = queue.popleft() if cur == target: return step if cur in visited: continue visited.add(cur) for j in range(4): code_up = self.up(cur, j) if not code_up in visited: queue.append(code_up) code_down = self.down(cur, j) if not code_down in visited: queue.append(code_down) step += 1 return -1 ","date":"2021-07-12","objectID":"/bfs/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - BFS","uri":"/bfs/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - LRU \u0026 LFU。","date":"2021-07-12","objectID":"/lrulfu/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - LRU \u0026 LFU","uri":"/lrulfu/"},{"categories":["Data Structures and Algorithms"],"content":"LRU class LRUCache: def __init__(self, capacity): self.capacity = capacity self.queue = collections.OrderedDict() def get(self, key): if key not in self.queue: return -1 value = self.queue.pop(key) self.queue[key] = value # 将命中的数据重新添加至头部 return self.queue[key] def put(self, key): if key in self.queue: # 若命中，则删除老数据 self.queue.pop(key) elif len(self.queue.items()) == self.capacity: # 未命中，且队列满，则删除最后一个数据 # popitem(last=True), 有序字典的 popitem() 方法移除并返回一个 (key, value) 键值对。 # 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对。 self.queue.popitem(last=False) # 删除最后添加的键值，网上有说随机删除一对并不准确 self.queue[key] = value ","date":"2021-07-12","objectID":"/lrulfu/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - LRU \u0026 LFU","uri":"/lrulfu/"},{"categories":["Data Structures and Algorithms"],"content":"LFU # 理解题意后发现会有三种查询关系，那索性建立三张表 # 先理出put和get接口框架，再补充increace_freq及remove_min_freq的细节 class LFUCache: def __init__(self, capacity: int): self.capacity = capacity self.key2val = {} self.key2freq = {} self.freq2keys = collections.defaultdict(collections.deque) self.min_freq = 1 def increase_freq(self, key: int): freq = self.key2freq[key] self.freq2keys[freq].remove(key) self.freq2keys[freq + 1].append(key) self.key2freq[key] = freq + 1 # update min_freq if freq == self.min_freq and len(self.freq2keys[freq]) == 0: self.min_freq = freq + 1 def remove_min_freq(self): key = self.freq2keys[self.min_freq].popleft() self.key2val.pop(key) self.key2freq.pop(key) # update min_freq if len(self.freq2keys[self.min_freq]) == 0: i = 0 while(i \u003c= len(self.key2val)): if not len(self.freq2keys[i]) == 0: self.min_freq = i break i += 1 def get(self, key: int) -\u003e int: if self.capacity \u003c= 0: return -1 if not key in self.key2val: return -1 self.increase_freq(key) return self.key2val[key] def put(self, key: int, value: int) -\u003e None: if self.capacity \u003c= 0: return if key in self.key2val: self.key2val[key] = value self.increase_freq(key) return if len(self.key2val) == self.capacity: self.remove_min_freq() # insert new key self.key2val[key] = value self.key2freq[key] = 1 self.freq2keys[1].append(key) if self.min_freq \u003e 1: self.min_freq = 1 ","date":"2021-07-12","objectID":"/lrulfu/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - LRU \u0026 LFU","uri":"/lrulfu/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 二分查找。","date":"2021-07-12","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Data Structures and Algorithms"],"content":"模板 1 - 二分查找 def binary_search(nums, target): if len(nums) \u003c= 0: return -1 left, right = 0, len(nums) - 1 # 查找区间[left, right] while left \u003c= right: mid = left + (right - left) // 2 if nums[mid] == target: return mid elif nums[mid] \u003c target: left = mid + 1 else: right = mid - 1 return -1 ","date":"2021-07-12","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Data Structures and Algorithms"],"content":"模板 2 - 查找左边界 def binary_search_left_bound(nums, target): if len(nums) \u003c= 0: return -1 left, right = 0, len(nums) # 查找空间[left, right) while left \u003c right: mid = left + (right - left) // 2 if nums[mid] = target: right = mid elif nums[mid] \u003c target: left = mid + 1 else: right = mid if left \u003c len(nums) and nums[left] = target: return left return -1 ","date":"2021-07-12","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Data Structures and Algorithms"],"content":"模板 3 - 查找右边界 def binary_search_right_bound(nums, target): if len(nums) \u003c= 0: return -1 left , right = 0, len(nums) # 查找空间[left, right) while left \u003c right: mid = left + (right - left) // 2 if nums[mid] == target: left = mid + 1 elif nums[mid] \u003c target: left = mid + 1 else: right = mid if left == 0 or not nums[left - 1] == target: return -1 return left - 1 ","date":"2021-07-12","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 寻找两个正序数组的中位数https://leetcode-cn.com/problems/median-of-two-sorted-arrays/ 寻找两个正序数组的中位数\r class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: k1 = ( len(nums1) + len(nums2) + 1 ) // 2 k2 = ( len(nums1) + len(nums2) + 2 ) // 2 # 二分法找第k小数，每次舍去某个数组的一半，因此可用递归实现 def helper(nums1,nums2,k): # 本质上是找第k小的数 if(len(nums1) \u003clen(nums2) ): nums1, nums2 = nums2 , nums1 #保持nums1比较长 if(len(nums2)==0): return nums1[k-1] # 短数组空，直接返回 if(k==1): return min(nums1[0],nums2[0]) # 找最小数，比较数组首位 t = min(k//2,len(nums2)) # 保证不上溢 if( nums1[t-1]\u003e=nums2[t-1] ): return helper(nums1 , nums2[t:],k-t) else: return helper(nums1[t:],nums2,k-t) return ( helper(nums1,nums2,k1) + helper(nums1,nums2,k2) ) /2 ","date":"2021-07-12","objectID":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 二分查找","uri":"/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 优先队列。","date":"2021-07-12","objectID":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 优先队列","uri":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["Data Structures and Algorithms"],"content":"简介优先队列算法，也成为堆队列算法。堆是一个二叉树，它的每个父节点都小于等于孩子节点。heapq实现了一个适合与Python的列表一起使用的最小堆排序算法，即heap[0]始终为最小元素。若要使用最大堆，可以将元素取相反数后入堆。 ","date":"2021-07-12","objectID":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 优先队列","uri":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["Data Structures and Algorithms"],"content":"heapq简介https://docs.python.org/zh-cn/3/library/heapq.html heapq\r ","date":"2021-07-12","objectID":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 优先队列","uri":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 数据流的中位数https://leetcode-cn.com/problems/find-median-from-data-stream/ 数据流的中位数\r # 两点注意： # 1. 我们规定奇数个元素时，queMin比queMax长度大一 # 2. python中的heapq是最小堆，即heap[0]为最小元素，所以对于queMin应该元素取负后入堆，这样-heap[0]是其最大值 class MedianFinder: def __init__(self): \"\"\" initialize your data structure here. \"\"\" # 结合列表来使用heapq模块 # queMin内为小于等于中位数的值，queMin[0]为中位数左侧值的相反数，长度可能比queMax长度大1 self.queMin = [] self.queMax = [] def addNum(self, num: int) -\u003e None: queMin = self.queMin queMax = self.queMax if not queMin or num \u003c -queMin[0]: # 先入queMin，若比queMax长度大2，则出堆并入queMax heapq.heappush(queMin, -num) if len(queMin) \u003e len(queMax) + 1: heapq.heappush(queMax, -heapq.heappop(queMin)) else: # 先入queMax，若比queMin长度大，则出堆并入queMin heapq.heappush(queMax, num) if len(queMax) \u003e len(queMin): heapq.heappush(queMin, -heapq.heappop(queMax)) def findMedian(self) -\u003e float: if len(self.queMin) \u003e len(self.queMax): return -self.queMin[0] else: return (self.queMax[0] - self.queMin[0]) / 2 ","date":"2021-07-12","objectID":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 优先队列","uri":"/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 前缀和。","date":"2021-07-12","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["Data Structures and Algorithms"],"content":"简介前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。 ","date":"2021-07-12","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 和为K的子数组https://leetcode-cn.com/problems/subarray-sum-equals-k/ 和为K的子数组\r class Solution: def subarraySum(self, nums: List[int], k: int) -\u003e int: num_times = collections.defaultdict(int) # 某前缀和出现的次数 num_times[0] = 1 # 先给定一个初值处理nums[0] = k的情况 cur_sum = 0 res = 0 for i in range(len(nums)): cur_sum += nums[i] # 计算当前前缀和 if cur_sum - k in num_times: # 若该前缀和出现过，则res加上出现的次数 res += num_times[cur_sum - k] num_times[cur_sum] += 1 return res ","date":"2021-07-12","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["Data Structures and Algorithms"],"content":"例题2 - 连续的子数组和https://leetcode-cn.com/problems/continuous-subarray-sum/ 连续的子数组和\r class Solution: def checkSubarraySum(self, nums: List[int], k: int) -\u003e bool: index_dict = dict() # 字典中存放余数第一次出现的索引，这里使用到同余定理， # 即a、b除k的余数相同时a - b能被k整除 cur_sum = 0 pre_sum = [] res = False index_dict[0] = -1 # 处理余数为0的情况 for i in range(len(nums)): cur_sum += nums[i] remainder = cur_sum % k if remainder not in index_dict: index_dict[remainder] = i continue if i - index_dict[remainder] \u003e 1: res = True return res ","date":"2021-07-12","objectID":"/%E5%89%8D%E7%BC%80%E5%92%8C/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 前缀和","uri":"/%E5%89%8D%E7%BC%80%E5%92%8C/"},{"categories":["Data Structures and Algorithms"],"content":"数据排列具有单调性的栈。","date":"2021-07-12","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["Data Structures and Algorithms"],"content":"简介 状态定义 状态转移方程 初始状态 返回值 ","date":"2021-07-12","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 打家劫舍IIhttps://leetcode-cn.com/problems/house-robber-ii/ 打家劫舍II\r 解题思路\r class Solution: def rob(self, nums: [int]) -\u003e int: def my_rob(nums): cur, pre = 0, 0 for num in nums: cur, pre = max(pre + num, cur), cur return cur return max(my_rob(nums[:-1]),my_rob(nums[1:])) if len(nums) != 1 else nums[0] ","date":"2021-07-12","objectID":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 动态规划","uri":"/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"categories":["Data Structures and Algorithms"],"content":"数据排列具有单调性的栈。","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"性质 单调递减栈，能表示入栈元素左边第一个比它大的元素。入栈表明本身比栈顶小，出栈表面本身比栈顶大； 单调递增栈，能表示入栈元素左边第一个比它小的元素。入栈表明本身比栈顶大，出栈表面本身比栈顶小； ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 接雨水https://leetcode-cn.com/problems/trapping-rain-water/ 接雨水\r class Solution: def trap(self, height: List[int]) -\u003e int: if len(height) == 0: return 0 sumArea = 0 stack = [] for right in range(len(height)): while stack and height[stack[-1]] \u003c height[right]: if len(stack) \u003e= 2: bottom = stack.pop() left = stack[-1] waterHeight = min(height[right], height[left]) - height[bottom] waterWidth = right - left - 1 currArea = waterHeight*waterWidth sumArea += currArea else: stack.pop() stack.append(right) return sumArea ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 股票价格跨度https://leetcode-cn.com/problems/online-stock-span/ 股票跨度\r 股票跨度-单调递减栈\r class StockSpanner: def __init__(self): self.stack = [] def next(self, price: int) -\u003e int: if not self.stack or self.stack[-1][0] \u003e price: self.stack.append((price, 1)) return 1 ans = 1 while self.stack and self.stack[-1][0] \u003c= price: bottom = self.stack.pop() ans += bottom[1] self.stack.append((price, ans)) return ans # Your StockSpanner object will be instantiated and called as such: # obj = StockSpanner() # param_1 = obj.next(price) ","date":"2021-07-12","objectID":"/%E5%8D%95%E8%B0%83%E6%A0%88/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 单调栈","uri":"/%E5%8D%95%E8%B0%83%E6%A0%88/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 回溯\u0026DFS。","date":"2021-07-12","objectID":"/%E5%9B%9E%E6%BA%AFdfs/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 回溯\u0026DFS","uri":"/%E5%9B%9E%E6%BA%AFdfs/"},{"categories":["Data Structures and Algorithms"],"content":"简介解决一个回溯问题，实际上就是一个决策树的遍历过程。你只需要思考 3 个问题： 路径：也就是已经做出的选择。 选择列表：也就是你当前可以做的选择。 结束条件：也就是到达决策树底层，无法再做选择的条件。 ","date":"2021-07-12","objectID":"/%E5%9B%9E%E6%BA%AFdfs/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 回溯\u0026DFS","uri":"/%E5%9B%9E%E6%BA%AFdfs/"},{"categories":["Data Structures and Algorithms"],"content":"框架 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 ","date":"2021-07-12","objectID":"/%E5%9B%9E%E6%BA%AFdfs/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 回溯\u0026DFS","uri":"/%E5%9B%9E%E6%BA%AFdfs/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - N皇后https://leetcode-cn.com/problems/n-queens/ N皇后\r class Solution: def __init__(self): self.res = [] def isvalid(self, board, row, col): # 无需检查行，因为按行遍历，每行只会有一个 # 检查列 r, c = row - 1, col while(r \u003e= 0): if board[r][c] == \"Q\": return False r -= 1 # 检查左上 r, c = row - 1, col - 1 while(r \u003e= 0 and c \u003e= 0): if board[r][c] == \"Q\": return False r -= 1 c -= 1 # 检查右上 r, c = row - 1, col + 1 while(r \u003e= 0 and c \u003c= len(board) - 1): if board[r][c] == \"Q\": return False r -= 1 c += 1 return True def update_row(self, board, row, col, l): # python中str类型不能直接修改，可以用字符串拼接 if col == 0: board[row] = l + board[row][1:] elif col == len(board) - 1: board[row] = board[row][:col] + l else: board[row] = board[row][:col] + l + board[row][col + 1:] def traceback(self, board, row): # 套用回溯框架 if len(board) == row: self.res.append(copy.deepcopy(board)) # 注意这里用深拷贝，因为回溯过程会不断修改board return for col in range(len(board)): if not self.isvalid(board, row, col): continue self.update_row(board, row, col, \"Q\") self.traceback(board, row + 1) self.update_row(board, row, col, \".\") def solveNQueens(self, n: int) -\u003e List[List[str]]: board = [\".\"*n for _ in range(n)] self.traceback(board, 0) return self.res ","date":"2021-07-12","objectID":"/%E5%9B%9E%E6%BA%AFdfs/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 回溯\u0026DFS","uri":"/%E5%9B%9E%E6%BA%AFdfs/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 字典树。","date":"2021-07-12","objectID":"/%E5%AD%97%E5%85%B8%E6%A0%91/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字典树","uri":"/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["Data Structures and Algorithms"],"content":"简介https://leetcode-cn.com/problems/short-encoding-of-words/solution/99-java-trie-tu-xie-gong-lue-bao-jiao-bao-hui-by-s/ 字典树，也叫Trie树或前缀树。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：最大限度地减少无谓的字符串比较。 这类很明显是用字典树去做的题目，明显特征就是需要大量地判断某个字符串是否是给定单词列表中的前缀/后缀。 为什么要说后缀也可以呢？因为把单词倒着插入，就可以搜后缀了。 ","date":"2021-07-12","objectID":"/%E5%AD%97%E5%85%B8%E6%A0%91/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字典树","uri":"/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["Data Structures and Algorithms"],"content":"模板 class TrieNode: def __init__(self): self.count = 0 self.preCount = 0 self.children = {} class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): # 插入一个单词 node = self.root for ch in word: if ch not in node.children: node.children[ch] = TrieNode() node = node.children[ch] node.preCount += 1 node.count += 1 def search(self, word): # 查找一个单词是否存在 node = self.root for ch in word: if ch not in node.children: return False node = node.children[ch] return node.count \u003e 0 def startsWith(self, prefix): # 查找是否存在以 word 为前缀的单词 node = self.root for ch in prefix: if ch not in node.children: return False node = node.children[ch] return node.preCount \u003e 0 ","date":"2021-07-12","objectID":"/%E5%AD%97%E5%85%B8%E6%A0%91/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字典树","uri":"/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 单词的压缩编码（后缀树）https://leetcode-cn.com/problems/short-encoding-of-words/ 单词的压缩编码\r class Trie: # 构造字典树 def __init__(self): \"\"\" Initialize your data structure here. \"\"\" self.Trie = {} def insert(self, word): \"\"\" Inserts a word into the trie. :type word: str :rtype: void \"\"\" curr = self.Trie for w in word: if w not in curr: curr[w] = {} curr = curr[w] curr['#'] = 1 def isTail(self, word): \"\"\" Returns if the word is in the trie. :type word: str :rtype: bool \"\"\" curr = self.Trie for w in word: curr = curr[w] return len(curr) == 1 class Solution: def minimumLengthEncoding(self, words: List[str]) -\u003e int: trie = Trie() cnt = 0 words = set(words) for word in words: trie.insert(word[::-1]) for word in words: if trie.isTail(word[::-1]): cnt += len(word) + 1 return cnt ","date":"2021-07-12","objectID":"/%E5%AD%97%E5%85%B8%E6%A0%91/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字典树","uri":"/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 字符串。","date":"2021-07-12","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字符串","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 最长回文子串https://leetcode-cn.com/problems/longest-palindromic-substring/ 最长回文子串\r # 双指针模板 String palindrome(String s, int l, int r) { // 防止索引越界 while (l \u003e= 0 \u0026\u0026 r \u003c s.length() \u0026\u0026 s.charAt(l) == s.charAt(r)) { // 向两边展开 l--; r++; } // 返回以 s[l] 和 s[r] 为中心的最长回文串 return s.substring(l + 1, r); } public String longestPalindrome(String s) { String res = \"\"; for (int i = 0; i \u003c s.length(); i++) { // 以 s[i] 为中心的最长回文子串 String s1 = palindrome(s, i, i); // 以 s[i] 和 s[i+1] 为中心的最长回文子串 String s2 = palindrome(s, i, i + 1); // res = longest(res, s1, s2) res = res.length() \u003e s1.length() ? res : s1; res = res.length() \u003e s2.length() ? res : s2; } return res; } # 动态规划 class Solution: def longestPalindrome(self, s: str) -\u003e str: n = len(s) if n \u003c 2: return s max_len = 1 begin = 0 # dp[i][j] 表示 s[i..j] 是否是回文串 dp = [[False] * n for _ in range(n)] for i in range(n): dp[i][i] = True # 递推开始 # 先枚举子串长度 for L in range(2, n + 1): # 枚举左边界，左边界的上限设置可以宽松一些 for i in range(n): # 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得 j = L + i - 1 # 如果右边界越界，就可以退出当前循环 if j \u003e= n: break if s[i] != s[j]: dp[i][j] = False else: if j - i \u003c 3: dp[i][j] = True else: dp[i][j] = dp[i + 1][j - 1] # 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置 if dp[i][j] and j - i + 1 \u003e max_len: max_len = j - i + 1 begin = i return s[begin:begin + max_len] 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 # 中心扩展法 class Solution: def expandAroundCenter(self, s, left, right): while left \u003e= 0 and right \u003c len(s) and s[left] == s[right]: left -= 1 right += 1 return left + 1, right - 1 def longestPalindrome(self, s: str) -\u003e str: start, end = 0, 0 for i in range(len(s)): left1, right1 = self.expandAroundCenter(s, i, i) left2, right2 = self.expandAroundCenter(s, i, i + 1) if right1 - left1 \u003e end - start: start, end = left1, right1 if right2 - left2 \u003e end - start: start, end = left2, right2 return s[start: end + 1] 作者：LeetCode-Solution 链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-07-12","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字符串","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 复原IP地址https://leetcode-cn.com/problems/restore-ip-addresses/ 复原IP地址\r class Solution: def restoreIpAddresses(self, s: str) -\u003e List[str]: #结果存储函数 result = [] #当前路径 path = [] #回溯函数 def back_track(s, index): #减枝，如果搜索路径大于4，直接返回 if len(path) \u003e 4: return #全部搜素完成，搜索路径等于4，则加入结果列表 if index == len(s) and len(path) == 4: result.append(\".\".join(path)) return #遍历整个字符串，对每一个满足的子串递归回溯 for i in range(index, len(s)): #减枝，如果当前值在0-255之前，则开始回溯 if 0 \u003c= int(s[index : i+ 1]) \u003c= 255: #如果当前值是0，但是不是一个单\"0\"则剪掉 if int(s[index : i+ 1]) == 0 and i != index: continue #如果当前值不是0，但是缺以\"0XXX\"开头，也应该剪掉 if int(s[index : i+ 1]) \u003e 0 and s[index] == \"0\": continue #加入当前path path.append(s[index: i+ 1]) #从当前节点开始递归 back_track(s, i + 1) #回溯 path.pop() back_track(s, 0) return result ","date":"2021-07-12","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字符串","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 3 - 基本计算器 IIhttps://leetcode-cn.com/problems/basic-calculator-ii/ 基本计算器 II\r 维护一个栈，存放所有的数字。遇到减号取反入栈。遇到乘除，则将栈顶数字出栈，与当前数字计算并将结果入栈。 最后只要求栈中所有数字和即可。 class Solution: def calculate(self, s: str) -\u003e int: n = len(s) stack = [] preSign = '+' num = 0 for i in range(n): if s[i] != ' ' and s[i].isdigit(): num = num * 10 + ord(s[i]) - ord('0') if i == n - 1 or s[i] in '+-*/': if preSign == '+': stack.append(num) elif preSign == '-': stack.append(-num) elif preSign == '*': stack.append(stack.pop() * num) else: stack.append(int(stack.pop() / num)) preSign = s[i] num = 0 return sum(stack) ","date":"2021-07-12","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字符串","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 4 - UTF-8编码验证https://leetcode-cn.com/problems/utf-8-validation/ UTF-8编码验证\r class Solution: def validUtf8(self, data): \"\"\" :type data: List[int] :rtype: bool \"\"\" # Number of bytes in the current UTF-8 character n_bytes = 0 # Mask to check if the most significant bit (8th bit from the left) is set or not mask1 = 1 \u003c\u003c 7 # Mask to check if the second most significant bit is set or not mask2 = 1 \u003c\u003c 6 for num in data: # Get the number of set most significant bits in the byte if # this is the starting byte of an UTF-8 character. mask = 1 \u003c\u003c 7 if n_bytes == 0: while mask \u0026 num: n_bytes += 1 mask = mask \u003e\u003e 1 # 1 byte characters if n_bytes == 0: continue # Invalid scenarios according to the rules of the problem. if n_bytes == 1 or n_bytes \u003e 4: return False else: # If this byte is a part of an existing UTF-8 character, then we # simply have to look at the two most significant bits and we make # use of the masks we defined before. if not (num \u0026 mask1 and not (num \u0026 mask2)): return False n_bytes -= 1 return n_bytes == 0 ","date":"2021-07-12","objectID":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 字符串","uri":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 差分。","date":"2021-07-12","objectID":"/%E5%B7%AE%E5%88%86/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 差分","uri":"/%E5%B7%AE%E5%88%86/"},{"categories":["Data Structures and Algorithms"],"content":"简介如果需要快速让数组中某个区间加上一个数，就需要用到差分。 ","date":"2021-07-12","objectID":"/%E5%B7%AE%E5%88%86/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 差分","uri":"/%E5%B7%AE%E5%88%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 拼车https://leetcode-cn.com/problems/car-pooling/ 拼车\r class Solution: def carPooling(self, trips: List[List[int]], capacity: int) -\u003e bool: des = 1000 # 最远点 f = [0] * des # 初始化差分队列 for x, L, R in trips: # 差分 f[L] += x f[R] -= x for i in range(1, des): f[i] = f[i-1] + f[i] if f[i] \u003e capacity: return False return True ","date":"2021-07-12","objectID":"/%E5%B7%AE%E5%88%86/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 差分","uri":"/%E5%B7%AE%E5%88%86/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 航班预订统计https://leetcode-cn.com/problems/corporate-flight-bookings/ 航班预订统计\r class Solution: def corpFlightBookings(self, bookings: List[List[int]], n: int) -\u003e List[int]: res = [0] * (n + 2) for first, last, seats in bookings: res[first] += seats res[last + 1] -= seats for i in range(1, n + 1): res[i] = res[i - 1] + res[i] return res[1:n + 1] ","date":"2021-07-12","objectID":"/%E5%B7%AE%E5%88%86/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 差分","uri":"/%E5%B7%AE%E5%88%86/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 广度优先搜索。","date":"2021-07-12","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 广度优先搜索","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"简介常用来解决最短路径问题。 ","date":"2021-07-12","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 广度优先搜索","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"模板 from collections import deque def search(name): # 广度优先搜索(BFS) search_quene = deque() search_quene += graph[name] # 传入初始节点 searched = [] # 避免重复处理 while search_quene: #队列中，pop()默认抛出右边元素，但是我们希望，append()从右边入队，popleft()从左边出队 person = search_quene.popleft() if person not in searched: # bingo()判断当前是不是我们要找的人 if bingo(person): return True else: search_quene += graph[person] searched.append(person) return False ","date":"2021-07-12","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 广度优先搜索","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 单词接龙https://leetcode-cn.com/problems/word-ladder/ 单词接龙\r class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e int: st=set(wordList) # 时间复杂都O(1)查找 if endWord not in st: return 0 m=len(beginWord) queue=collections.deque() queue.append((beginWord,1)) # 1表示step，即距离 visited=set() visited.add(beginWord) while queue: cur,step=queue.popleft() if cur==endWord: return step for i in range(m): # 对当前单词中每个字母用26个字母替换，若新单词在wordList中且未访问过，入队列 for j in range(26): tmp=cur[:i]+chr(97+j)+cur[i+1:] if tmp not in visited and tmp in st: queue.append((tmp,step+1)) visited.add(tmp) return 0 作者：yim-6 链接：https://leetcode-cn.com/problems/word-ladder/solution/python3-bfshe-shuang-xiang-bfsshi-xian-dan-ci-jie-/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 # 从beginWord和endWord分别做bfs，若从一端查到的节点已经在另一端的visited中，则说明可以相连且该节点为连接点 class Solution: def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -\u003e int: st=set(wordList) if endWord not in st: return 0 m=len(beginWord) lvisited=set() rvisited=set() lqueue=collections.deque() rqueue=collections.deque() lqueue.append(beginWord) rqueue.append(endWord) lvisited.add(beginWord) rvisited.add(endWord) step=0 while lqueue and rqueue: if len(lqueue)\u003elen(rqueue): lqueue,rqueue=rqueue,lqueue lvisited,rvisited=rvisited,lvisited step+=1 for k in range(len(lqueue)): cur=lqueue.popleft() if cur in rvisited: return step for i in range(m): for j in range(26): tmp=cur[:i]+chr(97+j)+cur[i+1:] if tmp not in lvisited and tmp in st: lqueue.append(tmp) lvisited.add(tmp) return 0 作者：yim-6 链接：https://leetcode-cn.com/problems/word-ladder/solution/python3-bfshe-shuang-xiang-bfsshi-xian-dan-ci-jie-/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-07-12","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 广度优先搜索","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 公交路线https://leetcode-cn.com/problems/bus-routes/ 公交路线\r class Solution: def numBusesToDestination(self, routes: List[List[int]], source: int, target: int) -\u003e int: # 每个车站可以乘坐的公交车 stations = defaultdict(set) for i, stops in enumerate(routes): for stop in stops: stations[stop].add(i) # 每个公交车线路可以到达的车站 routes = [set(x) for x in routes] q = deque([(source, 0)]) # 已经乘坐了的公交车 buses = set() # 已经到达了的车站 stops = {source} while q: pos, cost = q.popleft() if pos == target: return cost # 当前车站中尚未乘坐的公交车 for bus in stations[pos] - buses: # 该公交车尚未到达过的车站 for stop in routes[bus] - stops: buses.add(bus) stops.add(stop) q.append((stop, cost + 1)) return -1 ","date":"2021-07-12","objectID":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 广度优先搜索","uri":"/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 拓扑排序。","date":"2021-07-12","objectID":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 拓扑排序","uri":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["Data Structures and Algorithms"],"content":"简介在图论中，拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。 ","date":"2021-07-12","objectID":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 拓扑排序","uri":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 课程表 IIhttps://leetcode-cn.com/problems/course-schedule-ii/ 课程表 II\r class Solution: def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -\u003e List[int]: res = [] visited = [0] * numCourses adjacent = [[] for _ in range(numCourses)] # visited中包含两个状态 # 1：正在访问的路径，如果遍历时遇到1，说明图中有环，无法进行拓扑排序 # 2：已经访问过的路径，遇到直接跳过无需重复进入该节点 def dfs(i): if visited[i] == 1: return False if visited[i] == 2: return True visited[i] = 1 for j in adjacent[i]: if not dfs(j): return False visited[i] = 2 res.append(i) return True for cur, pre in prerequisites: adjacent[cur].append(pre) for i in range(numCourses): if not dfs(i): return [] return res ","date":"2021-07-12","objectID":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 拓扑排序","uri":"/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 深度优先搜索。","date":"2021-07-12","objectID":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 深度优先搜索","uri":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"简介本质就是枚举，只不过通过递归实现。 ","date":"2021-07-12","objectID":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 深度优先搜索","uri":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 最短的桥https://leetcode-cn.com/problems/word-ladder/ 最短的桥\r # 1. 先dfs找到一个岛，并染色成2 # 2. 将1的所有节点放入deque中进行bfs，找到另一个岛的步数即为结果 class Solution: def shortestBridge(self,nums): def dfs(i,j): # 把找到的一个岛染成2，同时把找个岛的所有坐标放到队列q if i\u003c0 or i\u003e=len(nums) or j\u003c0 or j\u003e=len(nums[0]) or nums[i][j]==0 or nums[i][j]==2: return if nums[i][j]==1: nums[i][j]=2 q.append((i,j)) for x,y in dirs: newi,newj=x+i,y+j dfs(newi,newj) def bfs(i,j): # 从找到的岛开始扩展，每扩展一层，steps+1 steps=0 while q: size=len(q) for _ in range(size): i,j=q.popleft() for x,y in dirs: newi,newj=x+i,y+j if newi\u003c0 or newi\u003e=len(nums) or newj\u003c0 or newj\u003e=len(nums[0]) or nums[newi][newj]==2: continue if nums[newi][newj]==1: return steps nums[newi][newj]=2 q.append((newi,newj)) steps+=1 # main dirs=((1,0),(0,1),(-1,0),(0,-1)) q=collections.deque() for i,row in enumerate(nums): for j,ele in enumerate(row): if ele==1: dfs(i,j) return bfs(i,j) ","date":"2021-07-12","objectID":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 深度优先搜索","uri":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 打家劫舍IIIhttps://leetcode-cn.com/problems/house-robber-iii/ 打家劫舍\r # Definition for a binary tree node. # class TreeNode: # def __init__(self, x): # self.val = x # self.left = None # self.right = None # 偷值为偷该节点时的最大金额，不偷值为不偷该节点（即偷其左右子节点）时的最大金额 class Solution: def rob(self, root: TreeNode) -\u003e int: a = self.helper(root) # a 是一个二维数组, 为root的[偷值, 不偷值] return max(a[0], a[1]) # 返回两个值的最大值, 此值为小偷最终获得的总值 # 参数为root节点, helper方法输出一个二维数组：root节点的[偷值, 不偷值] def helper(self, root): # 递归结束条件：root为空, 输出 [0, 0] if not root: return [0, 0] left = self.helper(root.left) # left是一个二维数组, 为 root 左侧子节点的[偷值, 不偷值] right = self.helper(root.right) # right也是一个二维数组, 为root右侧子节点的[偷值, 不偷值] robValue = left[1] + right[1] + root.val # root 的偷值 skipValue = max(left[0], left[1]) + max(right[0], right[1]) # root 的不偷值 return [robValue, skipValue] # 输出小偷可获得的最大金额 ","date":"2021-07-12","objectID":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 深度优先搜索","uri":"/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"categories":["Data Structures and Algorithms"],"content":"数据结构与算法 - 滑动窗口。","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"简介提到滑动窗口，最先想到的是TCP的流量控制，这里可以用来解决一些查找满足一定条件的连续区间的问题。 例子，给定数组为[2,3,1,2,4,3]，查找长度最小子数组，满足最小和s为7。当然可以枚举所有子数组求和，但会有很多重复计算，时间复杂度为O(N^2)，这里使用滑动窗口优化算法。 实现，给定一个滑动窗口，左右端分别为L和R，起始位置均为数组最左端。首先移动R，直至窗口区间满足给定条件，然后移动L，至区间不满足条件，再移动R。如此往复，并在过程中记录最优值。 ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:1","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"代码模板 def findSubArray(nums): N = len(nums) # 数组/字符串长度 left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间 sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数 res = 0 # 保存最大的满足题目要求的 子数组/子串 长度 while right \u003c N: # 当右边的指针没有搜索到 数组/字符串 的结尾 sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数 while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间 sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数 left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反 # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串 res = max(res, right - left + 1) # 需要更新结果 right += 1 # 移动右指针，去探索新的区间 return res 作者：fuxuemingzhu 链接：https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/fen-xiang-zhen-cang-de-hua-dong-chuang-k-e3rd/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:2","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 1 - 尽可能使字符串相等https://leetcode-cn.com/problems/get-equal-substrings-within-budget/ 尽可能使字符串相等\r class Solution: def equalSubstring(self, s: str, t: str, maxCost: int) -\u003e int: N = len(s) if N == 0: return 0 costs = [abs(ord(s[i]) - ord(t[i])) for i in range(N)] left, right = 0, 0 cost = 0 max_len = 0 while right \u003c N: cost += costs[right] while cost \u003e maxCost: cost -= costs[left] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:3","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 2 - 滑动窗口最大值https://leetcode-cn.com/problems/sliding-window-maximum/ 滑动窗口最大值\r class Solution: def maxSlidingWindow(self, nums: List[int], k: int) -\u003e List[int]: ''' 思路: 1. 利用双端队列记录当前滑动窗口的元素索引 2. 队列最左侧元素记录滑动窗口中最大元素的索引 3. 遍历数组： - 如果队列最左侧索引已不在滑动窗口范围内，弹出队列最左侧索引 - 通过循环确保队列的最左侧索引所对应元素值最大 - 新元素入队 - 从第一个滑动窗口的末尾索引开始将最大值存储到结果res中 ''' res = [] dq = deque() for i, v in enumerate(nums): if dq and dq[0] \u003c i - k + 1: dq.popleft() while dq and nums[dq[-1]] \u003c v: dq.pop() dq.append(i) if i \u003e= k - 1: res.append(nums[dq[0]]) return res ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:4","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"},{"categories":["Data Structures and Algorithms"],"content":"例题 3 - 串联所有单词的子串https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/ 串联所有单词的子串\r 这题最秀的地方不是滑动窗口，是如何判断子串是否满足条件。可以用两个 HashMap 来解决。 首先，我们把所有的单词存到 HashMap 里，key 直接存单词，value 存单词出现的个数（因为给出的单词可能会有重复的，所以可能是 1 或 2 或者其他）。然后扫描子串的单词，如果当前扫描的单词在之前的 HashMap 中，就把该单词存到新的 HashMap 中，并判断新的 HashMap 中该单词的 value 是不是大于之前的 HashMap 该单词的 value ，如果大了，就代表该子串不是我们要找的，接着判断下一个子串就可以了。如果不大于，那么我们接着判断下一个单词的情况。子串扫描结束，如果子串的全部单词都符合，那么该子串就是我们找的其中一个。 参考： https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/ class Solution: def findSubstring(self, s: str, words: List[str]) -\u003e List[int]: if not s or not words: return [] n = len(s) one_word_len = len(words[0]) word_cnt = len(words) all_len = one_word_len * word_cnt words_cnt = defaultdict(int) # 给定words的词数表 for w in words: words_cnt[w] += 1 res = [] for i in range(one_word_len): # 外层对一个单词长度循环，这里需要思考下， # 窗口给按单词长度滑动，这样可以覆盖所有情况 cur_w_num = 0 # 单词个数 L, R = i, i cur_w_dic = defaultdict(int) # 当前单词的次数统计 while R + one_word_len \u003c= len(s): w = s[R: R + one_word_len] R += one_word_len # R每次像右移一个单词的长度 if w not in words_cnt: # 结束前，出现个不知道哪里的单词，整个前面一片就废了 L = R cur_w_dic.clear() cur_w_num = 0 else: cur_w_dic[w] += 1 cur_w_num += 1 while cur_w_dic[w] \u003e words_cnt[w]: # 单词超量，移动L，更新计数 L_w = s[L : L + one_word_len] L += one_word_len cur_w_dic[L_w] -= 1 cur_w_num -= 1 if cur_w_num == word_cnt: # 满足条件，结果赋值 res.append(L) return res ","date":"2021-07-12","objectID":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/:0:5","tags":["Data Structures and Algorithms"],"title":"数据结构与算法 - 滑动窗口","uri":"/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]